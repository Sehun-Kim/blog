---
title: "[Network] HTTPS"
layout: post
date: 2019-02-25
image:
headerImage: false
tag:
- http
- https
category: blog
author: sehunkim
description: https의 탄생배경과 http와의 차잇점
star: false # true로할 경우 제목에 highlight 처리가 됨
sitemap :
  changefreq : daily
  priority : 1.0
---


## Https

#### Http의 약점

- 암호화 하지 않은 통신이라 도청 가능 : http에는 암호화 기능이 없다.
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능 : 서버에서 보낸, 혹은 클라이언트에서 보낸 리소스와 요청한 곳에서 받은 리소스가 완전히 일치하는지 확인할 수 없음



SSL이나 TLS라는 다른 프로토콜을 조합하여 통신내용을 암호화 할 수 있다. SSL을 활용하여 안전한 통신로를 확보한 상태에서 통신하는 것을 Https(HTTP Secure)라 부른다.

콘텐츠 자체를 암호화 하는 방법도 있다. 메시지의 헤더는 암호화 되어 있지 않고, 메시지 바디에 들어있는 콘텐츠만 암호화 하여 브라우저와 웹서버에서 각각 복호화 하는 것이다.

Http에서는 통신상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있다. SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 **증명서**를 제공하고 있다. 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이다.

요청과 응답의 변조를 막기위해 MD5, SHA-1 같은 해시값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법을 사용함



> HTTP + 통신의 암호화(SSL) + 증명서 + 리소스의 완전성 보호 = HTTPS



## Https란?

> http://soul0.tistory.com/372

http는 새로운 애플리케이션 계층의 프로토콜은 아니다.

![https layer](http://iloveulhj.github.io/images/https-basic/https-basic1.png)

HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 프로토콜로 대체하고 있을 뿐이다. 보통의 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL과 통신하고 SSL이 TCP와 통신한다. SSL이 껍질의 역할을 하는 것이다.

SSL을 사용하면서 암호화와 증명서, 완전성 보호등을 이용할 수 있게 되었다.

### 공개키 암호화 방식

SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용하고 있다.

현대의 암호는 알고리즘이 공개되어 있고 키를 비밀에 부침으로 안전성을 유지한다. 암호화나 복호화할 때 이 키를 사용하는데, 키가없으면 아무것도 못한다. 반대로 생각하면 키만 있으면 누구라도 암호를 풀 수 있다.

#### 공통키 암호화

암호화와 복호화에 하나의 키를 사용하는 것을 **공통키 암호화** 방식이라 한다. 공통키 암호화 방식은 상대방에게 키를 넘겨주지 않으면 안된다. 하지만 어떻게 안전하게 상대에게 키를 넘겨줄 수 있을까? 넘겨주는 과정에서 키를 빼앗기면 암호화의 의미가 없어진다. 키를 안전하게 보낼 수 있다면 애초에 암호화에 의미는 없어진다.

#### 공개키 암호화의 등장

공통키의 문제를 해결하기 위해 등장한 것이 **공개키 암호**라는 방식이다. 공개키 암호는 서로 다른 두 개의 키 페어를 사용한다. 한쪽은 비밀키, 한쪽은 공개키라 부른다.

- 비밀키 : 누구에게도 알려지면 안되는 키. 정보를 받아 들일 때 자신의 비밀키를 사용해 복호화한다.
- 공개키 : 암호를 보내는 측이 상대의 공개키를 사용해서 암호화함

암호문과 공개키만으로는 평문을 구하는 게 굉장히 어렵다.(큰 수의 소인수 분해를 고속으로 할 수 있다면 가능하지만 현재로선 불가능)

#### HTTPS는 하이브리드 암호 시스템

공개키 암호방식은 공통키 암호에 비해 처리속도가 늦다. 때문에 두 가지 장점을 모두 살릴 수 있도록 각각의 방식을 조합해서 통신한다.

키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용한다.

```
1. 공통키 암호로 사용하는 키를 공개키 암호를 사용하여 안전하게 교환
2. 공통키로 암호화한 내용을 전달
```



### 증명서

공개키가 진짜인지 아닌지 증명할 수 없기 때문에, 이를 해결하기 위해 인증기관(CA)과 그 기관이 발행하는 공개키 증명서가 이용되고 있다.

##### 인증기관의 인증 방식

```
1. 서버의 운영자가 인증기관에 공개키를 제출
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만듦
3. 공개키 인증서에 서명이 끝난 공개키를 담는다
4. 서버는 인증기관에 의해 작성된 공개키 인증서를 클라이언트에 보내 공개키 방식으로 통신을 한다.
```

> 디지털 서명은 인증기관의 공개키로 복호화해서 공개키가 진짜인지 확인하면 된다.
>
> 인증기관의 공개키는 안전하게 클라이언트에 전달 되어야 한다, 때문에 인증기관의 공개키는 브라우저에 내장된 상태로 출시되고 있다.



#### SSL은 느리다

HTTP 보다 SSL 통신만큼 네트워크 리소스를 더 소비하여 통신시간이 더 덜린다. 또한 서버, 클라이언트 모두 암호화와 복호화 처리를 해야하기 때문에 CPU, 메모리 등 하드웨어 리소스를 더 사용한다.

근본적인 해결 방식은 없어서 SSL 엑셀레이터라는 하드웨어(어플리케이션 서버)를 사용해서 문제를 해결하기도 한다.



---

## 인증

인증을 위한 정보

- 패스워드 : 본인만 아는 문자열 정보
- 원타임 토큰 : 본인만이 가지고 있는 기기 등에 표시되는 한번 쓰고 버리는 패스워드 정보
- 전자 증명서 : 본인(단말기)만이 가지고 있는 정보
- 바이오 매트릭스 : 지문이나 홍채 등 본인의 신체 정보
- IC 카드

## HTTP/1.1의 인증방법

### 1. Basic 인증

웹서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증방식

#### 인증 수순

```
1. 인증이 필요한 리소스에 리퀘스트 송신
2. 상태코드 401로 인증이 필요하다는 것 전달 (www-authenticate: basic realm="")
3. 유저ID와 PASSWORD를 Base64로 인코딩하여 송신
4. 인증 성공시 상태코드 200으로 응답 실패했을 경우 401로 응답
```

Base64라는 인코딩 형식은 암호화가 아니기 때문에 아무런 부가 정보 없이 복화화 가능함, 한번 Basic 인증을 하면 일반 브라우저에서는 로그아웃 할 수 없다.

### 2. DIGEST 인증

Basic 인증의 약점을 보완한 방식. Challenge Response 방식이 사용되고 있어, 패스워드를 있는 그대로 직접 보내는 일은 없다.

#### Challenge Response

![challenge Response](http://ocw.metu.edu.tr/pluginfile.php/2647/mod_resource/content/0/data%20protection%20II/chapterVII/002-4_1.jpg)

최초에 상대방에게 인증 요구를 보내고 상대에게서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산함. 이 값을 상대에게 송신하여 인증을 함

 Response Code라는 패스워드와 Challenge Code를 이용하여 계산한 결과를 상대에게 보내기 때문에 패스워드가 누출될 가능성이 줄어듬

#### 인증 수순

```
1. 인증이 필요한 리소스에 리퀘스트 송신
2. 서버가 401 Authorization Required 응답 하면서 인증이 필요하다고 전달 (www-authenticate: digest realm="", nonce"", algorithm="",qop="")
3. 클라이언트는 인증을 위해 필요한 정보를 반환한다. 이 때 username, realm, nonce, uri, response는 반드시 포함 되어야 한다. realm과 nonce는 서버에서 받은 것을 사용 함(authorization: digest realm="", nonce="", username="", uri="", response="", algorithm="")
4. 서버는 성공시 200 실패시 다시 401 응답
```

> nonce는 챌린지코드이다. 401 리스폰스를 반환할 때 마다 생성되는 유일한 문자열이다.
>
> response는 리스폰스 코드이다.
>
> username은 realm에서 인증 가능한 사용자 이름



### 3. SSL 인증

user id와 패스워드가 도난 당했을 경우 위장할 수 있다. SSL 방식은 https의 **클라이언트 인증서**를 이용한 인증 방식으로 사전에 등록되어 있는 클라이언트 증명서가 있을 때 활용할 수 있다.



#### 인증 수순

사전에 클라이언트에 클라이언트 증명서를 배포하고 설치해 놓아야 한다.

```
1. 인증이 필요한 리소스에 리퀘스트를 보냄
2. 서버에서 증명서를 요구하는 "Certificate Request" 메시지를 응답함
3. user는 송신하는 클라이언트 증명서를 선택하고 서버에 "Client Cerificate" 메시지를 보냄
4. 서버는 클라이언트 증명서를 검증하여 검증결과가 정확하면 클라이언트의 공개키를 얻는다. 이 후 Https에 의한 암호를 개시함
```

> SSL 클라이언트 인증에는 증명서 발급을 위한 돈이 필요하다.

SSL 클라이언트 인증은 단독으로 사용되지 않고 폼베이스 인증과 합쳐서 2-factor 인증의 하나로서 이용된다.

즉,  패스워드라는 한 개의 요소만이 아니라 이용자가 가진 다른 정보를 합쳐 인증하는 방식

- SSL 클라이언트 인증을 하여 클라이언트 컴퓨터를 인증하고
- 패스워드를 사용해서 유저의 본인확인을 한다.



### 폼베이스 인증

http 프로토콜로 사양이 정의된 인증 방식은 아님. **클라이언트**가 **서버상의 웹 어플리케이션**에 자격 정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식

어플리케이션마다 다르지만

```
1. 임의의 user ID, PASSWORD를 폼에 입력하여 웹 어플리케이션에 송신한다.
2. 검증이 성공하면 Session에 인증 상태를 저장한다.
```
