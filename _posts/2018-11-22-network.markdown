---
title: "[Network] 기초"
layout: post
date: 2018-11-22
image:
headerImage: false
tag:
- http
- https
category: blog
author: sehunkim
description: 네트워크 기초
star: false # true로할 경우 제목에 highlight 처리가 됨
sitemap :
  changefreq : daily
  priority : 1.0
---

## *주의*
<span class="evidence">미완성인 문서</span>

---

# HTTP

## Http 상태코드
![Screenshot]({{ site.url }}/assets/images/http_status_code.png)
상태코드는 요청에 대한 처리결과를 알려준다.
> 하지만 응답으로 돌아온 상태코드와 실제 상황이 불일치할 수 있다.
> 또, 브라우저는 응답을 받았을 때 제일 먼저 상태코드를 확인하여 성공여부를 파악한다.

### 2xx (Success)
2xx번대 리스폰스는 요청이 정상처리 되었음을 나타냄
#### 200 OK
#### 204 No Content
#### 207 Partial Content
Range에 의해 범위가 지정된 만큼 엔티티를 전달

### 3xx (Redirection)
리퀘스트가 정상적으로 종료되기 위해서 브라우저에서 특별한 처리를 수행해야 함.

#### 301 Moved Permanently
원하는 리퀘스트를 처리할 url이 아예 새로운 url이 부여 되어있기에 다음 요청부터는 해당 url을 참조해야한다고 명시
> 첫번째 요청은 302와 똑같이 요청을 원래 url에 보냈다가 다시 받은 location으로 요청을 보낸다. 두번째 요청부터 브라우저에서 캐싱하고 있던 url정보를 가지고 서버로 바로 보내는 것이 아니라. 아까 받은 location으로 보내게 됨.

- 브라우저에서 캐시를 삭제하지 않는한 서버단에서 변경사항이 적용되지 않을 수 있다. 때문에 주의해서 사용해야 한다.

#### 302 Found
요청을 보낸 리소스에 새로운 URI가 할당 되어 있기 때문에 일시적으로 해당 URI를 참조하라는 뜻. location 헤더에 있는 url로 다시 요청을 보낸다. (Post method를 Get으로 치환)

#### 304 Not Modified
클라이언트에서 보낸 조건부 요청에 대해 리소스에 대한 접근은 허락하지만 조건이 충족되지 않다.(사실 리다이렉트와는 관계 x)

### 4xx (Client Error)
클라이언트에 의해 에러가 발생했을 때

#### 400 Bad Request
요청의 구문이 잘못 되었음을 나타냄 (브라우저는 200 OK랑 똑같이 취급함)

#### 401 Unauthorized
받은 요청에 대해 Http 인증(Basic, Digest)이 필요하다는 것을 나타냄. 만약 한번 인증요청이 이루어진 경우 유저인증이 실패한 것을 표시함.
처음 401 응답을 받을 때 인증을 위한 다이얼이 표시된다.

#### 403 Forbidden
요청을 받은 리소스의 액세스가 거부되었을 때(허가되지 않은 접근), 거부된 이유는 엔티티 바디에 넣어 응답해줌

#### 404 Not Found
요청한 리소스가 서버상에 없을 때(url 잘못찍었을 때)

### 5xx (Server Error)
서버에 의해 에러가 발생했을 때

#### 500 Internal Server Error
요청을 처리하는 도중 서버에서 에러가 발생하였을 경우

#### 503 Service Unavailable
일시적으로 서버가 과부하 상태이거나 점검중일 때 현재 요청을 처리할 수 없음

---

## Http 메시지 헤더

![screenshot](https://t1.daumcdn.net/cfile/tistory/263764405780C33215)

메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어있다.

메시지 바디의 크기나 사용하고 있는 언어, 인증정보 등을 포함하고 있다.




헤더 영역은 이름과 값을 갖고 하나의 필드는 여러 값을 가질 수 있다.

```
헤더 필드 이름 : 값
```




#### Request

![request](http://www.icodeguru.com/dotnet/core.c.sharp.and.dot.net/0131472275/images/0131472275/graphics/17fig01.gif)

- 리퀘스트 라인 : 메소드, URI, HTTP 버전
- http header 필드
  리퀘스트 헤더 : 리퀘스트의 부가정보, 클라이언트의 정보, 리스폰스 콘텐츠에 대한 우선순위
  일반 헤더
  엔티티 헤더
- etc..



#### Response

![response](http://www.icodeguru.com/dotnet/core.c.sharp.and.dot.net/0131472275/images/0131472275/graphics/17fig02.gif)

- 상태라인 : Http 버전, 상태코드
- http header 필드
  일반 헤더
  리스폰스 헤더 : 리스폰스의 정보, 서버의 정보, 클라이언트의 추가 정보 요구
  엔티티 헤더





### end to end 헤더 , hop by hop 헤더

캐시와 비캐시 프록시의 동작을 정의하기 위한 두 가지 카테고리

#### End-to-end 헤더

리퀘스트나 리스폰스의 최종 수신자에게 전송됨, 캐시에서 구축된 리스폰스 중 보존되야 하고, 다시 전송되지 않으면 안되도록 되어있음

#### hop-by-hop 헤더

한 번 전송에 대해서만  유효하고 캐시와 프록시에 의해서 전송되지 않는 것도 있음. http 1.1에서는 첫 전송 이후에 사용되는 hop-by-hop 헤더는 connection 헤더 필드에 열거해야 함

```
- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- Trailer
- TE
- Transfer-Encoding
- Upgrade
```

위의 8개의 헤더 필드 이외에는 모두 end-by-end 헤더에 분류됨



### 1. 일반 헤더 필드

일반헤더필드는 리퀘스트와 리스폰스 양 쪽에서 사용되는 헤더



#### Cache-Control

디렉티브로 불리는 명령을 사용하여 캐싱동작을 지정함



##### 캐시 요청 디렉티브

HTTP 요청 내에서 클라이언트에 의해 사용될 수 있는 표준 `Cache-Control` 디렉티브.

```
Cache-Control: max-age=<seconds>
Cache-Control: max-stale[=<seconds>]
Cache-Control: min-fresh=<seconds>
Cache-control: no-cache
Cache-control: no-store
Cache-control: no-transform
Cache-control: only-if-cached
```



##### 캐시 응답 디렉티브

HTTP 응답 내에서 서버에 의해 사용될 수 있는 표준 `Cache-Control` 디렉티브.

```
Cache-control: must-revalidate
Cache-control: no-cache
Cache-control: no-store
Cache-control: no-transform
Cache-control: public
Cache-control: private
Cache-control: proxy-revalidate
Cache-Control: max-age=<seconds>
Cache-control: s-maxage=<seconds>
```

##### 디렉티브

캐시 능력

- `public`

  다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 뜻. 응답이 어떤 캐시에 의해서든 캐시된다는 것을 나타냅니다.

- `private`

  응답이 단일 사용자를 위한 것이며 public 캐시에 의해 저장되지 않아야 한다는 것을 나타냅니다. 사설 캐시는 응답을 저장할 수도 있습니다.
  캐시 서버는 특정 유저를 위해서 리소스를 캐시할 수 있지만 다른 유저로부터 같은 요청이 온다고 해도 그 캐시를 반환하지 않는다.

- `no-cache`

  캐시된 복사본을 사용자에게 보여주기 이전에, 재검증을 위한 요청을 원 서버로 보내도록 강제합니다. 오래된 리소스가 반환되는 것을 막기위해서.

  클라이언트의 리퀘스트로 no-cache가 있으면 캐시된 리스폰스를 클라이언트가 받아 들이지 않는다. 즉 중간 캐시 서버가 원래 서버까지 리퀘스트를 전송해야 한다.

  서버의 리스폰스에 no-cache 데렉티브가 사용된 경우 캐시 서버는 리소스를 저장할 수 없다. 원래 서버는 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인 하지 않고는 그 리스폰스를 사용하지 못하도록 한다.

  ```cache-control : no-cache=Location```

  필드값에 헤더 필드 명이 지정된 경우 지정된 헤더 필드만 캐시할 수 없다. 즉 지정된 헤더 필드 이외에는 캐시하는 것이 가능하다. 이것은 **리스폰스 디렉티브**만 사용가능하다.

- `only-if-cached`

  새로운 데이터를 내려받지 않음을 나타냅니다. 클라이언트는 캐시된 응답만을 원하며, 더 최신 복사본이 존재하는지를 알아보기 위해 서버에 요청해선 안됩니다.

만료

- `max-age=<seconds>`

  리소스가 최신 상태라고 판단할 최대 시간을 지정합니다. `Expires`에 반해, 이 디렉티브는 요청 시간과 관련이 있습니다.

- `s-maxage=<seconds>`

  `max-age` 혹은 `Expires` 헤더를 재정의하나, (프록시와 같은) 공유 캐시에만 적용되며 사설 캐시에 의해서는 무시됩니다.

- `max-stale[=<seconds>]`

  클라이언트가 캐시의 만료 시간을 초과한 응답을 받아들일지를 나타냅니다. 부가적으로, 초 단위의 값을 할당할 수 있는데, 이는 응답이 결코 만료되서는 안되는 시간을 나타냅니다.

- `min-fresh=<seconds>`

  클라이언트가 지정된 시간(초단위) 동안 신선한 상태로 유지될 응답을 원한다는 것을 나타냅니다.

- `stale-while-revalidate=<seconds>`

  비동기 적으로 백그라운드 에서 새로운 것으로 체크인하는 동안 클라이언트가 최신이 아닌 응답을 받아 들일 것임을 나타냅니다. 초 값은 클라이언트가 최신이 아닌 응답을 받아 들일 시간을 나타냅니다.

- `stale-if-error=<seconds>`


재검증과 리로딩

- `must-revalidate`

  캐시는 사용하기 이전에 기존 리소스의 상태를 반드시 확인해야 하며 만료된 리소스는 사용되어서는 안됩니다.

- `proxy-revalidate`

  `must-revalidate`와 동일하지만, (프록시와 같은)공유 캐시에만 적용되며 사설 캐시에 의해서는 무시됩니다.

- `immutable`

  응답 본문이 계속해서 변하지 않을 것이라는 것을 나타냅니다. 응답은, 만료되지 않은 경우라면, 서버 상에서 변경되지 않을 것이고 그러므로 클라이언트는 업데이트 검사를 위해 (`If-None-Match` 혹은 `If-Modified-Since`과 같은)그에 대한 조건부의 재검증을 전송해서는 안 됩니다. 이 확장을 감지하지못한 클라이언트는 HTTP 명세에 따라 그것들을 무시해야만 합니다. 파이어폭스에서, `immutable`는 `https://` 트랜잭션 상에서만 부여됩니다. 좀 더 많은 정보는 다음의 [블로그 포스트](http://bitsup.blogspot.de/2016/05/cache-control-immutable.html)를 참고하시기 바랍니다.

기타

- `no-store`

  기밀정보가 포함되어 있기 때문에 캐시는 클라이언트 요청 혹은 서버 응답에 관해서 어떤 것도 저장해서는 안됩니다.

- `no-transform`

  응답에 대해 변형이나 변환이 일어나서는 안됩니다. Content-Encoding, Content-Range, Content-Type 헤더는 프록시에 의해서 수정되어서는 안됩니다. 반투명 프록시는, 예를 들어, 캐시 공간을 절약하고 느린 링크 상의 트래픽량을 줄이기 위해 이미지 포맷들을 변환합니다. `no-transform` 디렉티브는 이를 허용하지 않습니다.

#### Connection

- 프록시에 더이상 전송하지 않는 헤더 필드를 지정
- 지속적 접속 관리

http 1.1에서는 지속적인 접속이 디폴트이지만 예전 버전은 지속적인 접속이 기본값이 아니다 때문에 ```Connection : Keep-Alive```를 지정해야함

#### Transfer-Encoding

메시지 바디의 전송 코딩형식을 정의한다. http 1.1 버전에는 chunked 방식만 있다.

`Transfer-Encoding : chunked`



### 2. 리퀘스트 헤더 필드

클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더. 부가 정보, 클라이언트 정보, 리스폰스 의 콘텐츠에 관한 우선 순위 등이 추가됨

#### Accept
> 요청을 보낼 때 클라이언트가 응답을 받아 처리할 수 있는 엔티티형식을 알려주는 필드

유저 에이전트가 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선 순위를 전달 하기 위해서 사용 됨

```
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

미디어 타입의 지정은 `타입/서브 타입`으로 지정. 한번에 여러 번 설정가능함

- 텍스트 파일
  text/html, text/plain, text/css
  application/xhtml+xml, application/xml
- 이미지 파일
  image/jpeg, image/gif, image/png
- 동영상 파일
  video/mpeg, video/quicktime
- 애플리케이션용 바이너리 파일
  application/octet-stream, application/zip

브라우저에서 처리 가능한 미디어 타입을 표시한다. 품질 지수(q)는 표시 안할 경우 가장 높은 값(1.0)이고, `;q=0.9` 이런 방식으로 품질 값을 정해 선호 순서를 지정할 수 있다.

#### Accept-Charset

유저 에이전트에서 처리할 수 있는 문자셋. 문자셋의 상대적인 우선순위를 전달하기 위해 사용. 한번에 여러개 가능. 품질 지수를 지정할 수 있다.

```
Accept-Charset: utf-8, iso-8859-1;q=0.5
```

#### Accept-Encoding

유저 에이전트가 처리할 수 있는 콘텐츠 코딩과 콘텐츠 코딩의 상대적인 우선순위를 전달하기 위해 사용.(클라이언트가 해석할 수 있는 암축 알고리즘이 무엇인지 알려준다.) 한 번에 여러개 지정 가능.

서버는 `Content-Encoding` 응답 헤더로 선택된 것이 무엇인지 클라이언트에게 알려줌

```
Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5
```

- gzip : 파일 압축프로그램 gzip(GNU zip)에서 생성된 인코딩 포맷. 32비트 CRC와 함께 [Lempel-Ziv coding](http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77) (LZ77)를 사용하는 압축 포맷.

- compress : UNIX 압축프로그램 compress에 의해 만들어진 인코딩 포맷. [Lempel-Ziv-Welch](http://en.wikipedia.org/wiki/LZW) (LZW) 알고리즘을 사용하는 압축 포맷.

- deflate

*deflate* 압축 알고리즘과 함께 [zlib](http://en.wikipedia.org/wiki/Zlib) 구조를 사용하는 압축 포맷.

- br : [Brotli](https://en.wikipedia.org/wiki/Brotli) 알고리즘을 사용하는 압축 포맷.

- identity : 압축과 변형을 안한 기본적인 경우. 식별 함수(**압축하지 않거나 수정하지 않은 경우**)를 가리킵니다. 이 값은 존재하지 않은 경우에도 항상 수용 가능하다고 여겨집니다.

- " * " :   와일드 카드로 모든 인코딩 포멧을 가리킴 헤더 내에 아직 나열되지 않은 컨텐츠 인코딩이라도 일치됩니다. 헤더가 존재하지 않을 경우, 기본값이 됩니다. 그것이 모든 알고리즘이 지원된다는 것을 의미하지는 않습니다; 단지 표현된 선호 대상이 없다는 것을 의미합니다.

#### Accept-Language

유저 에이전트가 처리할 수 있는 자연어의 세트와 자연어 세트의 우선순위를 전달 함

#### Authorization

유저 에이전트의 인증정보(크리덴셜 값)을 전달하기 위해서 사용된다.

```
Authorization: <type> <credentials>
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

서버에서 인증이 필요하다는 상태 코드  401 Unauthorized 와 인증 타입에 대해 오면 인증 타입에 맞추어 사용자명, 비밀번호를 인코딩하여 전달

보통 `Basic` 인증 스킴이 사용됨

- 사용자명과 비밀번호를 콜론을 이용하여 합침 (name:password)

- 결과에 대한 문자열을 base64로 인코딩함 (YWxhZGRpbjpvcGVuc2VzYW1l)

  > Base64 인코딩은 암호화나 해싱을 의미하지 않습니다! 이 방법은 인증에 대해서 문자를 그대로 보내는 것과 동일하다고 할 수 있습니다 (base64인코딩은 복호화 가능). Basic 인증을 하는 경우 HTTPS로 접속하는 것을 권장합니다.

#### Host

리퀘스트한 리소스의 인터넷 호스트와 포트 번호를 전달한다. http/1.1에서 유일한 필수헤더 필드이다. 존재 이유는 한 서버에서 복수의 도메인을 할당할 수 있는 가상 호스트의 구조와 관련이 있다.

```
Host: <host>:<port>
Host: developer.cdn.mozilla.net
```

리퀘스트가 서버에 오면 호스트명을 IP 주소로 바꾸어 레퀘스트가 처리된다. 만약 같은 IP 주소로 복수의 도메인이 적용되어 있다면 Host 헤더 필드에 리퀘스트를 받을 호스트명을 정확히 입력할 필요가 있다.

기본 port 번호는  80이고, 서버에 호스트명이 설정되어 있지 않으면 값을 비워서 보낸다.

#### If-Match

조건부 리퀘스트 . 서버상의 리소스를 특정하기 위해서 엔티티 태그(ETag)값을 전달한다. 이 때 서버는 약한 ETag값을 사용할 수 없다. 서버는 If-Match 필드의 값과 리소스의 Etag값이 일치하는 경우에만 리퀘스트를 받아 들일 수 있다. 일치하지 않으면 412 Precondition Failed 리스폰스를 반환한다.

```
If-Match: "bfc13a64729c4290ef5b2c2730249c88ca92d82d"

If-Match: W/"67ab43", "54ed21", "7892dd"

If-Match: *
```

#### If-Modified-Since

조건부 리퀘스트. 리소스가 갱신된 날짜가 필드값보다 새롭다면 응답을 보내라는 뜻. 없다면 304 Not Modified를 응답함

#### If-None-Match

조건부 리퀘스트. 필드에 지정된 Etag값이 지정된 리소스의 ETag 값과 일치하지 않으면 리퀘스트를 받아 응답을 해줌

#### If-Range

조건부 리퀘스트 필드의 Etag값 혹은 날짜와 지정한 리소스의 Etag값 혹은 날짜가 일치할 경우 Range 리퀘스트로 처리하고 싶다는 것을 전ㄱ달하고 일치 안하면 리소스 전체를 반환함

#### If-Unmodified-Since

지정된 리소스가 필드값에 지정된 날짜 이후에 갱신 되어 있지 않은 경우만 리퀘스트를 받아들임

#### Max-Forwards

필드에 값 만큼 서버를 경유할 수 있음 프록시 서버를 경유할 때 마다 1씩 감소됨. 문제가 발생한 경우의 원인조사에 활용되는 필드

#### Proxy-Authorization

프록시 서버의 인증요구를 받아 들일 때 인증에 필요한 클라이언트의 정보를 전달 함. 클라이언트와 서버의 HTTP 인증과 비슷하지만 다른 점은 클라이언트와 프록시 사이라는 것

#### Range

 range 헤더 필드는 리소스의 일부분만 취득하는 Range 리퀘스트를 할 때 지정 범위를 전달 함.

```

```

#### Referer

리퀘스트가 발생한 본래 리소스의 URI를 전달한다. 만약 보안상 바람직 하지 않다고 생각하면 생략해도 좋다.

(Referrer가 올바르지만 Referer로 쓰이고 있다.)

```
referer: https://developer.mozilla.org/ko/docs/Web/HTTP/Conditional_requests
```

#### User-Agent

리퀘스트를 생성한 브라우저와 유저 에이전트의 이름을 전달하기 위한 필드

```
user-agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Mobile Safari/537.36
```



### 3. 리스폰스 헤더 필드

서버측으로 부터 클라이언트 측으로 송신되는 리스폰스 메시지에 적용된 헤더. 리스폰스의 부가 정보나 클라이언트에 부가정보요구를 나타냄

#### Accept-Ranges

Range 리퀘스트가 수신 가능한지 여부를 응답해주는 필드

```
Accept-Ranges: bytes // 가능
Accept-Ranges: none // 불가능
```

#### Age

얼마나 오래전에 오리진 서버에서 리스폰스가 생성되었는지 전달함 (단위 : 초) 프록시에서 응답이 생성된 경우 해당 필드는 필수

```
Age: 600
```

#### ETag

엔티티 태그라고 불리며 특정 버전의 리소스를 식별하는 식별자이다. url상 리소스가 변경, 갱신되면 그 때마다 ETag값도 갱신된다. Etag값으로 캐시서버에서 오리진 서버와 비교하고 리소스 값을 갱신한다.

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

- 강한 ETag
  엔티티가 아주 조금 다르더라도 값을 반드시 변경시킴

  ```
  ETag: "Usagi-1234"
  ```

- 약한 ETag
  리소스가 같다는 것만을 나타낸다. 값의 앞에 W/를 붙힌다.

  ```
  ETag: W/"usagi-1234"
  ```



#### Location

응답 수신자에게 요청한 URI가 아닌 다른 리소스로 액세스하도록 유도할 때 사용된다. 3xx 번 때 상태 코드로 응답할 때 같이 쓰인다. 대부분의 브라우저는 Location 헤더 필드를 포함한 응답 메시지를 받으면 강제로 해당 리소스에 엑세스 시도

#### Proxy-Authenticate

프록시 서버에서의 인증요구를 클라이언트에 전달함

#### Retry-After

클라이언트가 일정시간 후에 리퀘스트를 다시 시행해야하는 지 전달함

#### Server

이 필드는 서버에 설치되어 있는 HTTP 서버의 소프트웨어를 전달한다.

```
Server: Apache/2.4.1 (Unix)
```

#### WWW-Authenticate

리퀘스트 URI에 지정했던 리소스에 적용할 수 있는 인증 스키마(Basic or Digest)와 파라미터를 나타내는 challenge를 전달한다.

```
WWW-Authenticate: Basic realm="Access to the staging site", charset="UTF-8"
```

상태코드 401 Unauthorized 응답에 무조건 포함된다. `realm`은 인증의 범위(요청 URI의 보호공간을 식별하기 위한 문자열)이다.



### 4. 엔티티 헤더 필드

리퀘스트, 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더. 콘텐츠의 갱신 시간 같은 엔티티의 정보를 포함함

#### Allow

```
Allow: GET,HEAD
```

리퀘스트 URI에 지정된 리소스가 제공하는 메소드의 일람을 전달함. 서버가 받을 수 없는 메소드를 수신한 경우 405 Method Not Allowed 상태코드와 함께 수신 가능한 메소드 일람을 기술한 헤더 필드를 반환함

#### Content-Encoding

서버가 엔티티 바디에 대해서 실시한 콘텐츠 코딩 형식을 전달함. 엔티티의 정보가 누락되지 않도록 압축할 것을 지시한다.

```
Content-Encoding: gzip
```

콘텐츠 코딩의 형식은 Accept-Encoding 헤더 필드에 서술된 내용과 같다.

#### Content-Language

엔티티 바디에 사용된 자연어를 전달

#### Content-Length

엔티티 바디의 크기(단위 bytes)

#### Content-Location

메시지 바디에 대응하는 URI를 전달함 `Location`헤더 필드와 달리 메시지 바디로 반환된 리소스의 URI를 나타냄

예를 들어 Accept_Language 필드를 이용해서 영어를 쓴다는 것을 알 경우 / url로 요청이 왔어도 실제 리소스는 index-en.html이 반환 될 수 있다.

#### Content-Range

Range 리퀘스트가 왔을 때 지정된 범위에 대해 응답할 때 사용된다.

```
Content-Range: bytes 5001-10000/10000
```

#### Content-Type
> 서버가 응답으로 보낸 바디안의 엔티티의 타입을 명시한 필드

엔티티 바디에 포함되는 리소스의 미디어 타입을 전달한다. Accept 필드와 같이 "타입/서브 타입"으로 기록함

charset 파라미터는 문자셋을 지정함

```
Content-Type: text/html; charset=utf-8
```



#### Expires

리소스의 유효기한 날짜를 전달한다. 캐시서버에서 Expires 헤더 필드를 포함한 리소스를 수신한 경우 지정된 날짜 까지 응답의 복사본을 유지하고 리퀘스트가 왔을 때 응답한다.

만약 Cache-Control 헤더 필드에 `max-age`디렉티브가 지정되어 있는 경우 `Expires`에 우선하여 지정됨

#### Last-Modified

리소스가 마지막으로 갱신되었던 날짜 정보를 전달. 기본적으로 요청 URI의 지정된 리소스가 갱신된 날짜가 되지만, 동적인 데이터를 다룰 경우 그 데이터의 최종 갱신날짜가 됨



### 5. 쿠키를 위한 헤더 필드

쿠키가 호출되었을 때는 쿠키의 유효기한과 송신지의 도메인, 경로, 프로토콜 등을 체크할 수 있기 때문에 적절하게 발행된 쿠키는 다른 웹사이트와 공격자의 공격에 의해 데이터가 도난 당하는 일은 없다.

#### Set-Cookie

리스폰스에 쓰이는 헤더 필드. 클라이언트에게 쿠키를 저장하라고 전달한다.

```
Set-Cookie: <cookie-name>=<cookie-value>; <property>
```
- Path : 쿠키에 지정된 값이 유효한 경로 ex) "/" /아래 모두
- Expires : 지정되지 않은 경우 브라우저가 닫힐 때 쿠키가 만료됨
- secure : 해당 필드 속성이 있으면 https일 때만 쿠키를 반송한다.
- HttpOnly : 자바스크립트를 경유해서 쿠키를 취득하지 못하도록하는 쿠키의 확장 기능

Secure 쿠키는 HTTPS 프로토콜 상에서 암호화된(encrypted ) 요청일 경우에만 전송됩니다. 하지만 `Secure`일지라도 민감한 정보는 절대 쿠키에 저장되면 안됩니다, 본질적으로 안전하지 않고 이 플래그가 당신에게 실질적인 보안(real protection)를 제공하지 않기 때문입니다. 크롬52 혹은 파이어폭스52로 시작한다면, 안전하지 않은 사이트(`http:`) 는 쿠키에 `Secure` 설정을 지시할 수 없습니다.

Cross-site 스크립팅 ([XSS](https://developer.mozilla.org/en-US/docs/Glossary/XSS)) 공격을 방지하기 위해, `HttpOnly`쿠키는 JavaScript의 [`Document.cookie`](https://developer.mozilla.org/ko/docs/Web/API/Document/cookie) API에 접근할 수 없습니다; 그들은 서버에게 전송되기만 합니다. 예를 들어, 서버 쪽에서 지속되고 있는 세션의 쿠키는 JavaScript를 사용할 필요성이 없기 때문에 `HttpOnly`플래그가 설정될 것이다.



#### Cookie

리퀘스트에 쓰이는 헤더 필드. 서버로 부터 수신한 쿠키를 이후의 리퀘스트에 포함해서 전달 함

```
Cookie: <cookie-name>=<cookie-value>; <cookie-name>=<cookie-value>;
```

---

## Https

#### Http의 약점

- 암호화 하지 않은 통신이라 도청 가능 : http에는 암호화 기능이 없다.
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능 : 서버에서 보낸, 혹은 클라이언트에서 보낸 리소스와 요청한 곳에서 받은 리소스가 완전히 일치하는지 확인할 수 없음



SSL이나 TLS라는 다른 프로토콜을 조합하여 통신내용을 암호화 할 수 있다. SSL을 활용하여 안전한 통신로를 확보한 상태에서 통신하는 것을 Https(HTTP Secure)라 부른다.

콘텐츠 자체를 암호화 하는 방법도 있다. 메시지의 헤더는 암호화 되어 있지 않고, 메시지 바디에 들어있는 콘텐츠만 암호화 하여 브라우저와 웹서버에서 각각 복호화 하는 것이다.

Http에서는 통신상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있다. SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 **증명서**를 제공하고 있다. 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이다.

요청과 응답의 변조를 막기위해 MD5, SHA-1 같은 해시값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법을 사용함



> HTTP + 통신의 암호화(SSL) + 증명서 + 리소스의 완전성 보호 = HTTPS



## Https란?

> http://soul0.tistory.com/372

http는 새로운 애플리케이션 계층의 프로토콜은 아니다.

![https layer](http://iloveulhj.github.io/images/https-basic/https-basic1.png)

HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 프로토콜로 대체하고 있을 뿐이다. 보통의 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL과 통신하고 SSL이 TCP와 통신한다. SSL이 껍질의 역할을 하는 것이다.

SSL을 사용하면서 암호화와 증명서, 완전성 보호등을 이용할 수 있게 되었다.

### 공개키 암호화 방식

SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용하고 있다.

현대의 암호는 알고리즘이 공개되어 있고 키를 비밀에 부침으로 안전성을 유지한다. 암호화나 복호화할 때 이 키를 사용하는데, 키가없으면 아무것도 못한다. 반대로 생각하면 키만 있으면 누구라도 암호를 풀 수 있다.

#### 공통키 암호화

암호화와 복호화에 하나의 키를 사용하는 것을 **공통키 암호화** 방식이라 한다. 공통키 암호화 방식은 상대방에게 키를 넘겨주지 않으면 안된다. 하지만 어떻게 안전하게 상대에게 키를 넘겨줄 수 있을까? 넘겨주는 과정에서 키를 빼앗기면 암호화의 의미가 없어진다. 키를 안전하게 보낼 수 있다면 애초에 암호화에 의미는 없어진다.

#### 공개키 암호화의 등장

공통키의 문제를 해결하기 위해 등장한 것이 **공개키 암호**라는 방식이다. 공개키 암호는 서로 다른 두 개의 키 페어를 사용한다. 한쪽은 비밀키, 한쪽은 공개키라 부른다.

- 비밀키 : 누구에게도 알려지면 안되는 키. 정보를 받아 들일 때 자신의 비밀키를 사용해 복호화한다.
- 공개키 : 암호를 보내는 측이 상대의 공개키를 사용해서 암호화함

암호문과 공개키만으로는 평문을 구하는 게 굉장히 어렵다.(큰 수의 소인수 분해를 고속으로 할 수 있다면 가능하지만 현재로선 불가능)

#### HTTPS는 하이브리드 암호 시스템

공개키 암호방식은 공통키 암호에 비해 처리속도가 늦다. 때문에 두 가지 장점을 모두 살릴 수 있도록 각각의 방식을 조합해서 통신한다.

키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용한다.

```
1. 공통키 암호로 사용하는 키를 공개키 암호를 사용하여 안전하게 교환
2. 공통키로 암호화한 내용을 전달
```



### 증명서

공개키가 진짜인지 아닌지 증명할 수 없기 때문에, 이를 해결하기 위해 인증기관(CA)과 그 기관이 발행하는 공개키 증명서가 이용되고 있다.

##### 인증기관의 인증 방식

```
1. 서버의 운영자가 인증기관에 공개키를 제출
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만듦
3. 공개키 인증서에 서명이 끝난 공개키를 담는다
4. 서버는 인증기관에 의해 작성된 공개키 인증서를 클라이언트에 보내 공개키 방식으로 통신을 한다.
```

> 디지털 서명은 인증기관의 공개키로 복호화해서 공개키가 진짜인지 확인하면 된다.
>
> 인증기관의 공개키는 안전하게 클라이언트에 전달 되어야 한다, 때문에 인증기관의 공개키는 브라우저에 내장된 상태로 출시되고 있다.



#### SSL은 느리다

HTTP 보다 SSL 통신만큼 네트워크 리소스를 더 소비하여 통신시간이 더 덜린다. 또한 서버, 클라이언트 모두 암호화와 복호화 처리를 해야하기 때문에 CPU, 메모리 등 하드웨어 리소스를 더 사용한다.

근본적인 해결 방식은 없어서 SSL 엑셀레이터라는 하드웨어(어플리케이션 서버)를 사용해서 문제를 해결하기도 한다.



---

## 인증

인증을 위한 정보

- 패스워드 : 본인만 아는 문자열 정보
- 원타임 토큰 : 본인만이 가지고 있는 기기 등에 표시되는 한번 쓰고 버리는 패스워드 정보
- 전자 증명서 : 본인(단말기)만이 가지고 있는 정보
- 바이오 매트릭스 : 지문이나 홍채 등 본인의 신체 정보
- IC 카드

## HTTP/1.1의 인증방법

### 1. Basic 인증

웹서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증방식

#### 인증 수순

```
1. 인증이 필요한 리소스에 리퀘스트 송신
2. 상태코드 401로 인증이 필요하다는 것 전달 (www-authenticate: basic realm="")
3. 유저ID와 PASSWORD를 Base64로 인코딩하여 송신
4. 인증 성공시 상태코드 200으로 응답 실패했을 경우 401로 응답
```

Base64라는 인코딩 형식은 암호화가 아니기 때문에 아무런 부가 정보 없이 복화화 가능함, 한번 Basic 인증을 하면 일반 브라우저에서는 로그아웃 할 수 없다.

### 2. DIGEST 인증

Basic 인증의 약점을 보완한 방식. Challenge Response 방식이 사용되고 있어, 패스워드를 있는 그대로 직접 보내는 일은 없다.

#### Challenge Response

![challenge Response](http://ocw.metu.edu.tr/pluginfile.php/2647/mod_resource/content/0/data%20protection%20II/chapterVII/002-4_1.jpg)

최초에 상대방에게 인증 요구를 보내고 상대에게서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산함. 이 값을 상대에게 송신하여 인증을 함

 Response Code라는 패스워드와 Challenge Code를 이용하여 계산한 결과를 상대에게 보내기 때문에 패스워드가 누출될 가능성이 줄어듬

#### 인증 수순

```
1. 인증이 필요한 리소스에 리퀘스트 송신
2. 서버가 401 Authorization Required 응답 하면서 인증이 필요하다고 전달 (www-authenticate: digest realm="", nonce"", algorithm="",qop="")
3. 클라이언트는 인증을 위해 필요한 정보를 반환한다. 이 때 username, realm, nonce, uri, response는 반드시 포함 되어야 한다. realm과 nonce는 서버에서 받은 것을 사용 함(authorization: digest realm="", nonce="", username="", uri="", response="", algorithm="")
4. 서버는 성공시 200 실패시 다시 401 응답
```

> nonce는 챌린지코드이다. 401 리스폰스를 반환할 때 마다 생성되는 유일한 문자열이다.
>
> response는 리스폰스 코드이다.
>
> username은 realm에서 인증 가능한 사용자 이름



### 3. SSL 인증

user id와 패스워드가 도난 당했을 경우 위장할 수 있다. SSL 방식은 https의 **클라이언트 인증서**를 이용한 인증 방식으로 사전에 등록되어 있는 클라이언트 증명서가 있을 때 활용할 수 있다.



#### 인증 수순

사전에 클라이언트에 클라이언트 증명서를 배포하고 설치해 놓아야 한다.

```
1. 인증이 필요한 리소스에 리퀘스트를 보냄
2. 서버에서 증명서를 요구하는 "Certificate Request" 메시지를 응답함
3. user는 송신하는 클라이언트 증명서를 선택하고 서버에 "Client Cerificate" 메시지를 보냄
4. 서버는 클라이언트 증명서를 검증하여 검증결과가 정확하면 클라이언트의 공개키를 얻는다. 이 후 Https에 의한 암호를 개시함
```

> SSL 클라이언트 인증에는 증명서 발급을 위한 돈이 필요하다.

SSL 클라이언트 인증은 단독으로 사용되지 않고 폼베이스 인증과 합쳐서 2-factor 인증의 하나로서 이용된다.

즉,  패스워드라는 한 개의 요소만이 아니라 이용자가 가진 다른 정보를 합쳐 인증하는 방식

- SSL 클라이언트 인증을 하여 클라이언트 컴퓨터를 인증하고
- 패스워드를 사용해서 유저의 본인확인을 한다.



### 폼베이스 인증

http 프로토콜로 사양이 정의된 인증 방식은 아님. **클라이언트**가 **서버상의 웹 어플리케이션**에 자격 정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식

어플리케이션마다 다르지만

```
1. 임의의 user ID, PASSWORD를 폼에 입력하여 웹 어플리케이션에 송신한다.
2. 검증이 성공하면 Session에 인증 상태를 저장한다.
```
